import { Injectable, NgZone } from '@angular/core';
import io from 'socket.io-client';
import type { Socket } from 'socket.io-client';
import { Device, types } from 'mediasoup-client';

@Injectable({ providedIn: 'root' })
export class MediasoupService {
    private socket!: any;
    private device!: Device;
    private recvTransport!: types.Transport;
    private consumers: types.Consumer[] = [];

    constructor(private ngZone: NgZone) {}

    /**
     * Initialize and start receiving a stream.
     * @param streamId ID of the stream to consume
     * @param videoElement HTMLVideoElement to render video
     */
    async initStream(streamId: string, videoElement: HTMLVideoElement) {
        // 1Ô∏è‚É£ Connect to Socket.IO
        console.log('üîó Connecting to mediasoup server...');
        this.socket = io('http://localhost:3002', {
            transports: ['websocket'],
        });

        this.socket.on('connect', async () => {
            console.log('‚úÖ Connected to mediasoup server');

            // 2Ô∏è‚É£ Load Device with RTP capabilities
            console.log('üì¶ Loading mediasoup Device...');
            this.device = new Device();
            console.log('[device]', this.device);
            const routerRtpCapabilities = await this.request(
                'getRouterRtpCapabilities',
                { streamId }
            );
            console.log(
                'üì¶ Router RTP capabilities received:' + routerRtpCapabilities
            );
            await this.device.load({ routerRtpCapabilities });
            console.log(
                'üì¶ Device loaded with routerRtpCapabilities:',
                this.device
            );
            if (!this.device.rtpCapabilities) {
                console.error('‚ùå Failed to load mediasoup Device');
                return;
            }
            console.log('üì¶ Device loaded successfully');

            // 3Ô∏è‚É£ Create recv transport
            console.log(
                'üì° Client rtpCapabilities:',
                this.device.rtpCapabilities
            );
            console.log('üöö Creating recv transport...');
            const { id, iceParameters, iceCandidates, dtlsParameters } =
                await this.request('joinStream', {
                    streamId,
                    rtpCapabilities: this.device.rtpCapabilities,
                });

            console.log(
                `üöö Recv transport parameters: id=${id}, iceParameters=${iceParameters}, dtlsParameters=${dtlsParameters}`
            );

            this.recvTransport = this.device.createRecvTransport({
                id,
                iceParameters,
                iceCandidates,
                dtlsParameters,
            });
            console.log(`üöö Recv transport created: ${id}`);

            // 4Ô∏è‚É£ Connect DTLS
            console.log('üîí Connecting recv transport...');
            this.recvTransport.on(
                'connect',
                ({ dtlsParameters }, callback, errback) => {
                    console.log(
                        `üîí Connected transport ${id} with DTLS parameters: ${dtlsParameters}`
                    );
                    this.socket.emit(
                        'connectTransport',
                        { transportId: id, dtlsParameters },
                        (res: any) => {
                            console.log(
                                `üîí [connectTransport] Transport connection response: ${res}`
                            );
                            res === 'connected' ? callback() : errback(res);
                        }
                    );
                }
            );

            this.recvTransport.on('connectionstatechange', (state) => {
                console.log(`üîó Transport state: ${state}`);
            });

            // 5Ô∏è‚É£ Consume

            console.log('üëÄ Requesting consume...');
            const consumerInfos = await this.request('consume', {
                streamId,
                rtpCapabilities: this.device.rtpCapabilities,
            });
            console.log(
                `üëÄ Received ${consumerInfos.length} consumer infos:`,
                consumerInfos
            );
            if (!consumerInfos.length) {
                console.error('‚ùå No producers available');
                return;
            }

            // 6Ô∏è‚É£ Create local consumers
            console.log('üé• Creating local consumers...');
            for (const info of consumerInfos) {
                const consumer = await this.recvTransport.consume({
                    id: info.id,
                    producerId: info.producerId,
                    kind: info.kind,
                    rtpParameters: info.rtpParameters,
                });
                this.consumers.push(consumer);

                console.log(`üé• Consumer created: ${consumer.id}, kind=${consumer.kind}`);

                // Attach events to the consumer's track
                consumer.track.onmute = () => console.log(`üîá Track ${consumer.id} muted`);
                consumer.track.onunmute = () => console.log(`üì° Track ${consumer.id} unmuted`);

                // For video, attach its track to the video element
                if (consumer.kind === 'video') {
                    // Ensure track is enabled
                    consumer.track.enabled = true;

                    const stream = new MediaStream([consumer.track]);
                    // Run outside Angular zone if needed
                    this.ngZone.runOutsideAngular(() => {
                        console.log(`üîÑ Setting up video element for consumer ${consumer.id}`);
                        videoElement.srcObject = stream;
                        videoElement.muted = false; // make sure video element is not muted to see audio if necessary

                        // Wait until metadata is loaded before playing
                        videoElement.onloadedmetadata = () => {
                            console.log('üìë Video metadata loaded, attempting playback');
                            videoElement.play().then(() => {
                                console.log(`‚úÖ Video playback started for consumer ${consumer.id}`);
                                console.log('üéûÔ∏è Track settings:', consumer.track.getSettings?.());
                                console.log('üéûÔ∏è Track readyState:', consumer.track.readyState);
                                console.log('üéûÔ∏è MediaStream tracks:', stream.getTracks());
                                console.log('üéûÔ∏è Video element readyState:', videoElement.readyState);
                                console.log('üéûÔ∏è Video element paused:', videoElement.paused);

                            }).catch((err) => {
                                console.error('Error during video playback:', err);
                            });
                        };

                        // Fallback in case onloadedmetadata does not fire
                        setTimeout(() => {
                            if (videoElement.paused) {
                                videoElement.play().then(() => {
                                    console.log(`‚úÖ Fallback: Video playback started for consumer ${consumer.id}`);
                                    console.log('üéûÔ∏è Track settings:', consumer.track.getSettings?.());
                                    console.log('üéûÔ∏è Track readyState:', consumer.track.readyState);
                                    console.log('üéûÔ∏è MediaStream tracks:', stream.getTracks());
                                    console.log('üéûÔ∏è Video element readyState:', videoElement.readyState);
                                    console.log('üéûÔ∏è Video element paused:', videoElement.paused);

                                }).catch((err) => {
                                    console.error('Fallback error during video playback:', err);
                                });
                            }
                        }, 1000);
                    });
                }

                // Resume consumer on server
                console.log(`‚ñ∂Ô∏è Resuming consumer ${consumer.id}`);
                await this.request('resume', { consumerId: consumer.id });

                // Optionally, start logging consumer stats (unchanged code)
                setInterval(async () => {
                    try {
                        const stats = await consumer.getStats();
                        
                        stats.forEach((stat: any) => {
                            if (stat.type === 'inbound-rtp' && stat.kind === 'video') {
                                console.log(`üìà Packets received:`, stat.packetsReceived);
                                console.log(`üìà Frames decoded:`, stat.framesDecoded);
                                console.log(
                                    `üîç Consumer ${consumer.id} inbound RTP: packetsReceived=${stat.packetsReceived}, bytesReceived=${stat.bytesReceived}, framesDecoded=${stat.framesDecoded}`
                                );
                            }
                        });
                    } catch (err) {
                        console.error(`Error getting stats for consumer ${consumer.id}`, err);
                    }
                }, 1000);
            }

            // 8Ô∏è‚É£ Periodically log transport stats to verify packet flow
            console.log('üîç Setting up transport stats logging...');
            setInterval(async () => {
                try {
                    const stats = await this.recvTransport.getStats();
                    console.log('üîç recvTransport stats:', stats);
                } catch (err) {
                    console.error('Error getting recvTransport stats', err);
                }
            }, 2000);

            console.log('Debugging info:');
            this.request('debug', {
                streamId,
                rtpCapabilities: this.device.rtpCapabilities,
            });
        });
    }

    /**
     * Helper to emit Socket.IO events and await response
     */
    private request(event: string, data: any): Promise<any> {
        return new Promise((resolve, reject) => {
            this.socket.emit(event, data, (res: any) => {
                if (res?.error) reject(res.error);
                else resolve(res);
            });
        });
    }
}
